use regex::Regex;
use std::{collections::BTreeMap, fmt::Write, path::PathBuf};
use walkdir::WalkDir;

fn mangle_comments(s: &str) -> String {
    let result = s
        .split('\n')
        .map(str::trim)
        .filter_map(|line| line.strip_prefix("/// "))
        .filter(|line| !line.starts_with("# ")) // filter out code
        .map(|line| if line.starts_with("```") { "" } else { line })
        .collect::<Vec<_>>();
    result.join("\n")
}

const PREFIX: &str = r#"// autogenerated. Please look at /tests/check-docs.rs

#[allow(clippy::too_many_lines)]
#[rustfmt::skip]
fn explain(lint: &str) {
    println!("{}", match lint {
"#;

const SUFFIX: &str = r#"        _ => "unknown lint",
    });
}
"#;

static CODE_FILE: &str = "src/docs.rs";

#[test]
fn gen_docs() {
    let src = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("clippy_lints/src");
    let lint_regex = Regex::new(r"(?s)declare_clippy_lint!\s*\{(.*?)\n\s*pub\s+([A-Z_]+),.*?\n\}").unwrap();
    let mut lints = BTreeMap::new();
    for file in WalkDir::new(src) {
        let file = file.unwrap();
        let file = file.path();
        if file.extension() != Some("rs".as_ref()) {
            continue;
        }
        let contents = std::fs::read_to_string(file).unwrap();
        for cap in lint_regex.captures_iter(&contents) {
            let lint_id = cap[2].to_ascii_lowercase();
            let comments = mangle_comments(&cap[1]);
            lints.insert(lint_id, comments);
        }
    }
    let mut code = String::from(PREFIX);
    for (lint, comments) in lints {
        writeln!(&mut code, r#"        "{lint}" => {comments:?},"#).unwrap();
    }
    code += SUFFIX;

    let previous = std::fs::read_to_string(CODE_FILE).unwrap_or_default();
    if previous != code {
        std::fs::write(CODE_FILE, code).unwrap();
        panic!("file was changed. Please review the result.");
    }
}
